<!DOCTYPE html>
<html>
	<head>
		<title>Snap Crack</title>
		<style>
			#wrap {
				width: 642px;
				height: 960px;
				margin : 0 auto;
				background: #dddddd;
				background: -moz-linear-gradient(top, #dddddd 0%, #ffffff 100%);
				background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#dddddd), color-stop(100%,#ffffff));
				background: -webkit-linear-gradient(top, #dddddd 0%, #ffffff 100%);
				background: -o-linear-gradient(top, #dddddd 0%, #ffffff 100%);
				background: -ms-linear-gradient(top, #dddddd 0%, #ffffff 100%);
				background: linear-gradient(to bottom, #dddddd 0%, #ffffff 100%);
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#dddddd', endColorstr='#ffffff', GradientType=0);
			}
			canvas {
				margin: 0 auto;
				display: block;
				border: 1px solid #c9c9c9;
			}
		</style>
	</head>
	<body>
		<div id="wrap">
			<canvas id="snap-crack" width="640" height="960"></canvas>
		</div>
		<script>
			// Main game object.
			var snap = {
				// Brick.
				Brick: function (e) {
					this.image = new Image();
					this.image.src = 'img/brick.svg';
					this.width = 100;
					this.height = 143;
					this.x = (canvas.width - this.width) / 2;
					this.xRate = 5;
					this.y = 100;
					this.yRate = 8;

					this.flipping = false;
					this.flipFrames = [];
					this.flipIndex = 0;
					this.flipTicks = 0;
					this.ticksPerFrame = 6;

					this.moveLeft = false;
					this.moveRight = false;

					this.deadFrame = null;

					this.jitter = false;
				},

				// Coins.
				Coin: function (x, y) {
					this.width = 28;
					this.height = 28;
					this.x = x;

					this.yPos = 960 + y;
					this.yRate = 7;
					this.y = function () {
						return this.yPos -= this.yRate;
					}
				},

				// Clouds.
				Cloud: function () {
					this.width = snap.randNum(250, 350);
					this.height = 100;
					this.x = -150 + snap.altSign(snap.randNum(0, 640));

					this.yPos = 960 + (snap.altSign(snap.randNum(0, 1) * 50));
					this.yRate = 5;
					this.y = function () {
						return this.yPos -= this.yRate;
					};
				},

				// Floor.
				Floor: function () {
					this.width = 670;
					this.height = 185;
					this.x = -15;
					this.y = 960;
					this.yRate = 5;
				},

				// Score.
				Score: function () {},

				// Timer.
				Timer: function () {
					this.limit = snap.time;
				},

				// Controls.
				controls: function (e) {
					switch (e.keyCode) {
						// Space bar.
						case 32:
							if (!snap.spaceHeld) {
								snap.player.flipping = true;
								snap.spaceHeld = true;
							}
							if (e.type === 'keyup') {
								snap.spaceHeld = false;
							}

							// For intro screen only:
							if (snap.startScreen) {
								snap.startScreen = false;
							}
							break;
						// Left arrow.
						case 37:
							snap.player.moveLeft = true;
							if (e.type === 'keyup') {
								snap.player.moveLeft = false;
							}
							break;
						// Right arrow.
						case 39:
							snap.player.moveRight = true;
							if (e.type === 'keyup') {
								snap.player.moveRight = false;
							}
							break;
					}
				},

				// Global helpers.
				startScreen: true,
				spaceHeld: false,	// Helper to disable space-down.
				lastSign: false,	// Helper for altSign utility function.

				// Game settings.
				fps: 40,
				time: 10000,

				// Utility.
				randNum: function (low, high) {
					var result = Math.floor(Math.random() * (high + 1));
					if (result < low) {
						return this.randNum(low, high);
					} else {
						return result;
					}
				},
				randSign: function (value) {
					if (Math.round(Math.random()) === 0) {
						return -value;
					} else {
						return value;
					}
				},
				altSign: function (value) {
					if (this.lastSign) {
						this.lastSign = false;
						return -value;
					} else {
						this.lastSign = true;
						return value;
					}
				},
				drawText: function (object) {
					// This function accepts an object with settings:
					// strings: font, fill, text, align, x, y
					if (object.hasOwnProperty('font')) {
						ctx.font = object['font'];
					}
					if (object.hasOwnProperty('fill')) {
						ctx.fillStyle = object['fill'];
					}
					if (object.hasOwnProperty('text')) {
						ctx.textAlign = object['align'];
						ctx.fillText(object['text'], object.x, object.y);
					} else {
						return 'Supply text, alignment, x and y.';
					}
				},
				// A bounce object should be generated and associated width
				// whatever object it's being used for.
				Bounce: function (low, high, increment) {
					this.low = low;
					this.high = high;
					this.increment = increment;
					this.range = [];

					this.lastIndex = 0;

					// Build the range array which we will iterate through
					// to get the "bounce" effect between 2 values.
					for (var i = this.low, j = this.high; i <= j; i += this.increment) {
						this.range.push(i);
					}
					for (var i = this.high, j = this.low; i >= j; i -= this.increment) {
						this.range.push(i);
					}
				},

				// Active objects.
				player: null,
				floor: null,
				timer: null,

				clouds: [],
				coins: [],

				// Game setup.
				setup: function () {
					// Clear all game objects.
					this.player = null;
					this.floor = null;
					this.timer = null;

					// Generate new player.
					this.player = new snap.Brick();
					// Populate player flip frames.
					for (var i = 0; i < 8; i++) {
						this.player.flipFrames[i] = i * 100;
					}

					// Make a bounce object for intro screen.
					this.introBounce = new snap.Bounce(0.2, 0.8, 0.003);

					// Generate a timer.
					this.timer = new snap.Timer();

					// Generate floor.
					this.floor = new snap.Floor();

					// Assign event listeners.
					window.addEventListener('keydown', this.controls);
					window.addEventListener('keyup', this.controls);
				},

				// Intro screen.
				startit: function (fps) {
					ctx.clearRect(0, 0, canvas.width, canvas.height);

					// Tapping space bar will start the game.
					if (this.startScreen) {

						// Draw clouds.
						this.clouds.draw();

						// Draw intro text.
						this.drawText({
							font: 'bold 76px Arial',
							fill: 'rgba(0,0,0,.8)',
							align: 'center',
							x: 320,
							y: 350,
							text: 'Snap Crack'
						});
						this.drawText({
							font: '22px Arial',
							align: 'center',
							x: 320,
							y: 440,
							text: 'Collect coins to offset your medical bills.'
						});
						this.drawText({
							align: 'center',
							x: 320,
							y: 485,
							text: 'Try to grab them mid-spin to double their value.'
						});
						this.drawText({
							align: 'center',
							x: 320,
							y: 530,
							text: 'Land on your feet to mitigate fall damage!'
						});
						this.drawText({
							font: '30px Arial',
							fill: 'rgba(0,0,0,' + this.introBounce.get() + ')',
							align: 'center',
							x: 320,
							y: 705,
							text: 'Hit space to spin and start!'
						});

						setTimeout(function () {
							snap.startit();
						}, 1000 / fps);
					} else {
						snap.timer.init();
						this.init(fps);
					}
				},

				// Game loop.
				init: function (fps) {
					ctx.clearRect(0, 0, canvas.width, canvas.height);

					// Main game loop tied to timer.
					if (this.timer.get() > 0) {
						// When we get close to time out, activate the floor.
						if (this.timer.get() < 0.5) {
							if (this.floor.y > 805) {
								this.floor.y -= this.floor.yRate;
							}
							this.floor.draw();
							// And activate the end sequence (player actually falls).
							if (this.player.y < 715) {
								this.player.y += this.player.yRate;
								this.player.xRate = 0;
							} else {
								this.player.deadFrame = this.player.flipIndex;
								// Remove event listeners.
								window.removeEventListener('keydown', this.controls);
								window.removeEventListener('keyup', this.controls);
							}
						}

						// Draw clouds.
						this.clouds.draw();

						// Draw coins.
						this.coins.draw();

						// Draw the player.
						this.player.draw();

						setTimeout(function () {
							snap.init();
						}, 1000 / fps);
					} else {
						this.endit(fps);
					}
				},

				// Game end.
				endit: function (fps) {
					ctx.clearRect(0, 0, canvas.width, canvas.height);

					// Draw the floor.
					this.floor.draw();

					// Draw the player.
					this.player.draw();

					setTimeout(function () {
						snap.endit();
					}, 1000 / fps);
				}
			};

			snap.Bounce.prototype = {
				constructor: snap.Bounce,
				// Return the next value in the bounce sequence per call.
				get: function () {
					if (this.lastIndex < this.range.length - 1) {
						var result = this.range[this.lastIndex];
						this.lastIndex += 1;
						return result;
					} else {
						this.lastIndex = 0;
						return this.range[this.lastIndex];
					}
				}
			};

			snap.Brick.prototype = {
				constructor: snap.Brick,
				// Unless spacebar pressed, default to falling image.
				draw: function () {
					// Draw function handles all player states.
					// If the main game loop has ended, draw the end frame only.
					if (this.deadFrame !== null) {
						ctx.drawImage(this.image, this.flipFrames[this.deadFrame], 
							0, 100, 142, this.x, this.y, 100, 142);
					} else {
						// Depending on 'flipping' flag, serves different images.
						if (!this.flipping) {
							this.fall();
						} else {
							this.flip();
						}

						// Listen for left/right movement flags.
						if (this.moveLeft) {
							this.x -= this.xRate;
						} else if (this.moveRight) {
							this.x += this.xRate;
						}
						// If x-coord moves out of bounds, set x to bound limits.
						if (this.x <= 0) {
							this.x = 0;
						} else if (this.x >= 540) {
							this.x = 540;
						}
					}

					return this;
				},
				fall: function () {
					ctx.drawImage(this.image, 0, 0, 100, 142, this.x, this.y, 100, 142);
				},
				flip: function () {
					if (this.flipIndex > 7) {
						ctx.drawImage(this.image, 0, 0, 100, 142, this.x, this.y, 100, 142);
						this.flipping = false;
						this.flipIndex = 0;
					} else {
						this.flipTicks += 1;

						if (this.flipTicks > this.ticksPerFrame) {
							this.flipTicks = 0;
							this.flipIndex += 1;
						}

						ctx.drawImage(this.image,
							this.flipFrames[this.flipIndex],
							0, 100, 142, this.x, this.y, 100, 142);
					}
				}
			};

			snap.Coin.prototype = {
				constructor: snap.Coin
			};
			snap.coins.draw = function () {
				// Coin generation is based on RNG.
				if (snap.randNum(0, 100) === 50) {
					snap.coins.generate();
				}

				if (snap.coins.length === 0) {
					return;
				}

				// Remove coins that are out of bounds or collected.
				for (c in snap.coins) {
					if (snap.coins[c]['yPos'] < -30) {
						snap.coins.splice(c, 1);
					}
					if (snap.coins[c] != undefined && snap.coins.collisionCheck(snap.coins[c])) {
						snap.coins.splice(c, 1);
					}
				}

				// Draw coins to canvas.
				for (var i = 0, j = this.length; i < j; i++) {
					var coin = this[i];
					ctx.fillStyle = snap.coins.color;
					ctx.fillRect(coin.x, coin.y(), coin.width, coin.height);
				}
			};
			snap.coins.generate = function () {
				var pattern = function () {
					return snap.randNum(0, 10);
				};

				switch (pattern()) {
					case 1:
						var numCoins = snap.randNum(5, 10);
						var xPos = snap.randNum(70, 540);
						for (var i = 0, y = 0; i < numCoins; i++) {
							snap.coins.push(new snap.Coin(xPos, y));
							y += snap.coins.yGap;
						}
						break;
					case 2:
						var numCoins = snap.randNum(3, 5);
						var xPos = snap.randNum(70, 100);
						for (var i = 0, y = 0; i < numCoins; i++) {
							snap.coins.push(new snap.Coin(xPos, y));
							y += snap.coins.yGap;
							xPos += snap.coins.xGap;
						}
						break;
					case 3:
						var numCoins = snap.randNum(3, 5);
						var xPos = snap.randNum(510, 540);
						for (var i = 0, y = 0; i < numCoins; i++) {
							snap.coins.push(new snap.Coin(xPos, y));
							y += snap.coins.yGap;
							xPos -= snap.coins.xGap;
						}
						break;
					case 4:
						var numLines = snap.randNum(3, 5);
						var numCoins = numLines * 13;
						var xPos = 70;
						for (var i = 0, y = 0; i < numLines; i++) {
							for (var j = 0; j < 13; j++) {
								snap.coins.push(new snap.Coin(xPos, y));
								xPos += snap.coins.xGap;
							}
							y += snap.coins.yGap;
							xPos = 70;
						}
						break;
				}
			};
			snap.coins.collisionCheck = function (coin) {
				var coinLeft = coin.x,
					coinRight = coin.x + coin.width,
					coinTop = coin.yPos,
					coinBottom = coin.yPos + coin.height;
				var playerLeft = snap.player.x,
					playerRight = snap.player.x + snap.player.width,
					playerTop = snap.player.y,
					playerBottom = snap.player.y + snap.player.height;

				// Check top/bottom bounds, then left/right bounds.
				if (playerBottom > coinTop && playerTop < coinBottom) {
					if (playerRight > coinLeft && playerLeft < coinRight) {
						return true;
					}
					
				} else {
					return false;
				}
			};
			snap.coins.color = '#999';
			snap.coins.yGap = 70;
			snap.coins.xGap = 40;
			Object.defineProperties(snap.coins, {
				'draw': {enumerable: false},
				'generate': {enumerable: false},
				'collisionCheck': {enumerable: false},
				'color': {enumerable: false},
				'yGap': {enumerable: false},
				'xGap': {enumerable: false}
			});

			snap.Cloud.prototype = {
				constructor: snap.Cloud
			};
			snap.clouds.draw = function () {
				// Generate cloud clusters every so often.
				if (snap.clouds.ticks > snap.clouds.maxTicks) {
					snap.clouds.ticks = 0;
					snap.clouds.make();
				} else {
					snap.clouds.ticks += 1;
				}
				// Remove clouds from game that leave canvas area.
				for (cloud in snap.clouds) {
					if (snap.clouds[cloud]['yPos'] < -100) {
						snap.clouds.splice(cloud, 1);
					}
				}

				for (var i = 0; i < this.length; i++) {
					var cloud = this[i];
					ctx.fillStyle = '#fff';
					ctx.fillRect(cloud.x, cloud.y(), cloud.width, cloud.height);
				}
			};
			// Logic to make random cloud shapes.
			snap.clouds.make = function () {
				for (var i = 0; i < 2; i++) {
					snap.clouds.push(new snap.Cloud());
				}
			};
			// Logic to pace cloud generation.
			snap.clouds.maxTicks = 100;
			snap.clouds.ticks = snap.clouds.maxTicks;

			snap.Floor.prototype = {
				constructor: snap.Floor,
				draw: function () {
					ctx.fillStyle = '#ccc';
					ctx.fillRect(this.x, this.y, this.width, this.height);
				}
			};

			snap.Timer.prototype = {
				constructor: snap.Timer,
				init: function () {
					if (snap.time > 0) {
						setTimeout(function () {
							snap.time -= 100;
							snap.timer.init();
						}, 100);
					}
				},
				get: function () {
					return snap.time / 1000;
				}
			};

			// Start the game loop.
			var canvas = document.getElementById('snap-crack');
			ctx = canvas.getContext('2d');

			snap.setup();
			snap.startit(snap.fps);

			/*
				------------
				RANDOM IDEAS
				------------

				- Randomly generate a timer limit every round.
				- Add altitude info box.

			*/

		</script>
	</body>
</html>